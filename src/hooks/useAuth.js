// hooks/useAuth.js
import { onAuthStateChanged, signInWithPopup, signInWithRedirect, getRedirectResult, GoogleAuthProvider } from "firebase/auth";
import { auth, db } from "../api/firebase";
import { doc, setDoc, getDoc } from "firebase/firestore";
import { useNavigate } from "react-router-dom";
import { useEffect, useState } from "react";

// Auth service with all the business logic
export const authService = {
    // Function to create/update user profile in Firestore
    createUserProfileInFirestore: async (user) => {
        const generateRandomUsername = () => {
            const adjectives = ['Swift', 'Brave', 'Clever', 'Bright', 'Bold'];
            const nouns = ['Scholar', 'Learner', 'Student', 'Warrior', 'Master'];
            const num = Math.floor(Math.random() * 999) + 1;
            return `${adjectives[Math.floor(Math.random() * adjectives.length)]}${nouns[Math.floor(Math.random() * nouns.length)]}${num}`;
        };

        const userRef = doc(db, "users", user.uid);
        const userDoc = await getDoc(userRef);

        const now = new Date();
        const nextMonthStart = new Date(now.getFullYear(), now.getMonth() + 1, 1);

        if (!userDoc.exists()) {
            console.log('ðŸ“ Creating new Firestore user profile...');

            const autoGeneratedDisplayName = generateRandomUsername();

            // Create the basic profile WITHOUT party assignment
            // AuthProvider will handle party assignment
            const userProfileData = {
                email: user.email,
                displayName: autoGeneratedDisplayName || "New User",
                createdAt: user.metadata.creationTime ? new Date(user.metadata.creationTime) : now,
                lastActiveAt: now,
                lastStudyDate: null,
                
                // These will be set by AuthProvider after party assignment
                level: 1,
                exp: 0,
                health: 100,
                mana: 100,
                currentPartyId: null,
                autoAssignedAt: null,
                hasChosenAvatar: false,
                avatar: "warrior_01",
                prefersSolo: false,
                
                stats: {
                    totalReviews: 0,
                    weeklyReviews: 0,
                    currentStreak: 0,
                    longestStreak: 0
                },
                
                subscription: {
                    tier: "free",
                    expiresAt: null
                },
                
                limits: {
                    aiGenerationsUsed: 0,
                    currentCards: 0,
                    currentDecks: 0,
                    smartReviewDecks: 0,
                    currentFolders: 0,
                    aiGenerationsResetAt: nextMonthStart,
                    maxAiGenerations: 20,
                    maxCards: 100,
                    maxDecks: 5,
                    maxSmartReviewDecks: 2,
                    maxFolders: 10
                },
                
                tutorials: {
                    "create-deck": { completed: false, step: 1 },
                    "smart-review": { completed: false, step: 1 },
                    "global-review": { completed: false, step: 1 },
                    "deck-sharing": { completed: false, step: 1 }
                }
            };

            // Just create the profile - AuthProvider will handle party assignment
            await setDoc(userRef, userProfileData);
            console.log("âœ… Firestore profile created for:", user.email);
            console.log("â³ Party assignment will be handled by AuthProvider...");
            
        } else {
            console.log('ðŸ”„ Updating lastActiveAt for existing user:', user.email);
            
            // Don't assign party here either - let AuthProvider handle it
            await setDoc(userRef, { lastActiveAt: new Date() }, { merge: true });
        }
    },

    // Main sign-in function
    signIn: async (options = {}) => {
        const { onSuccess, onError, navigate } = options;
        
        try {
            console.log('ðŸ” Starting authentication flow...');
            
            const provider = new GoogleAuthProvider();
            provider.addScope('email');
            provider.addScope('profile');
            provider.setCustomParameters({
                prompt: 'select_account'
            });
            
            try {
                console.log('ðŸ”„ Using popup authentication...');
                const result = await signInWithPopup(auth, provider);
                const user = result.user;
                console.log('âœ… User signed in via popup:', user.displayName, user.email);
                
                // Let AuthProvider's onAuthStateChanged handle profile creation
                // and party assignment automatically
                
                if (onSuccess) onSuccess(user);
                
            } catch (popupError) {
                console.log('âŒ Popup failed, trying redirect as fallback...');
                
                if (popupError.code === 'auth/popup-blocked' || 
                    popupError.code === 'auth/popup-closed-by-user' ||
                    popupError.code === 'auth/web-storage-unsupported') {
                    
                    console.log('ðŸ“± Falling back to redirect...');
                    
                    try {
                        sessionStorage.setItem('signInIntent', 'true');
                        sessionStorage.setItem('signInTimestamp', Date.now().toString());
                    } catch (storageError) {
                        console.log('âš ï¸ Storage unavailable, continuing without backup');
                    }
                    
                    await signInWithRedirect(auth, provider);
                } else {
                    throw popupError;
                }
            }
            
        } catch (error) {
            console.error('âŒ Error during sign-in:', error);
            
            try {
                sessionStorage.removeItem('signInIntent');
                sessionStorage.removeItem('signInTimestamp');
            } catch (e) {
                console.log('âš ï¸ Could not clear storage');
            }
            
            let errorMessage = 'Error signing in. Please try again.';
            if (error.code === 'auth/popup-closed-by-user') {
                errorMessage = 'Sign-in was cancelled. Please try again.';
            } else if (error.code === 'auth/popup-blocked') {
                errorMessage = 'Pop-up was blocked. Please allow pop-ups for this site or try again.';
            } else if (error.code === 'auth/unauthorized-domain') {
                errorMessage = 'Domain not authorized. Please add your domain to Firebase Console.';
            } else if (error.code === 'auth/web-storage-unsupported') {
                errorMessage = 'Your browser has storage restrictions. Please enable cookies and try again.';
            } else if (error.message) {
                errorMessage = `Error: ${error.message}`;
            }
            
            if (onError) onError(errorMessage);
            else alert(errorMessage);
        }
    },

    signOut: async (options = {}) => {
        const { onSuccess, onError, navigate } = options;
        
        try {
            await auth.signOut();
            console.log('âœ… User signed out');
            if (onSuccess) onSuccess();
            if (navigate) navigate('/');
        } catch (error) {
            console.error('âŒ Error signing out:', error);
            const errorMessage = 'Error signing out. Please try again.';
            if (onError) onError(errorMessage);
            else alert(errorMessage);
        }
    }
};

// Custom hook for auth state
export const useAuth = () => {
    const [authUser, setAuthUser] = useState(null);
    const [authLoading, setAuthLoading] = useState(true);
    const [debugInfo, setDebugInfo] = useState('');
    const navigate = useNavigate();

    useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            console.log('ðŸ”¥ Auth state changed:', user ? user.email : 'Not signed in');
            setAuthUser(user);
            setAuthLoading(false);
            setDebugInfo(`Auth: ${user ? user.email : 'Not signed in'} at ${new Date().toLocaleTimeString()}`);
        });

        return () => unsubscribe();
    }, []);

    useEffect(() => {
        const checkRedirectResult = async () => {
            try {
                console.log('ðŸ” Checking redirect result...');
                const result = await getRedirectResult(auth);

                if (result) {
                    const user = result.user;
                    console.log('âœ… User signed in via redirect:', user.email);
                    setDebugInfo(`Redirect success: ${user.email}`);
                    
                    // Let AuthProvider handle profile creation and party assignment
                    navigate('/');
                }
            } catch (error) {
                console.error('âŒ Error getting redirect result:', error);
                setDebugInfo(`Redirect error: ${error.message}`);
                
                if (error.code === 'auth/unauthorized-domain') {
                    alert('Domain not authorized. Please add your domain to Firebase Console.');
                } else if (error.code === 'auth/operation-not-allowed') {
                    alert('Google sign-in not enabled. Please enable it in Firebase Console.');
                } else {
                    alert(`Error completing sign-in: ${error.message}`);
                }
            }
        };

        checkRedirectResult();
    }, [navigate]);

    return {
        authUser,
        authLoading,
        debugInfo,
        signIn: (options = {}) => authService.signIn({ navigate, ...options }),
        signOut: (options = {}) => authService.signOut({ navigate, ...options }),
        authService
    };
};