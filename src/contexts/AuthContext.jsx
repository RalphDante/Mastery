// contexts/AuthContext.js - CORE AUTH ONLY
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import { 
    onAuthStateChanged, 
    signInWithEmailAndPassword, 
    createUserWithEmailAndPassword,
    signOut,
    sendPasswordResetEmail,
    updateProfile
} from 'firebase/auth';
import { doc, getDoc, setDoc, updateDoc } from 'firebase/firestore';
import { auth, db } from '../api/firebase';

const AuthContext = createContext();

export const useAuthContext = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuthContext must be used within an AuthProvider');
    }
    return context;
};

export const AuthProvider = ({ children }) => {
    console.log('ðŸ” AuthProvider rendered');
    const [user, setUser] = useState(null);
    const [userProfile, setUserProfile] = useState(null);
    const [loading, setLoading] = useState(true);
    const [authLoading, setAuthLoading] = useState(false);

    // Listen for authentication state changes - THIS IS THE ONLY EFFECT
    useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
            if (firebaseUser) {
                setUser(firebaseUser);
                console.log('ðŸ”¥ Auth state changed:', firebaseUser.email);
                await fetchUserProfile(firebaseUser.uid);
            } else {
                console.log('User signed out');
                setUser(null);
                setUserProfile(null);
            }
            setLoading(false);
        });

        return unsubscribe;
    }, []); // Only run once on mount

    // Fetch user profile from Firestore
    const fetchUserProfile = async (userId) => {
        try {
            const userRef = doc(db, 'users', userId);
            const userDoc = await getDoc(userRef);
            
            if (userDoc.exists()) {
                let profileData = userDoc.data();

                // Subscription expiration check
                const subscription = profileData.subscription || {};
                const now = new Date();
                
                if (subscription.tier === 'pro' && 
                    subscription.expiresAt && 
                    subscription.expiresAt.toDate() <= now &&
                    (subscription.status === 'active' || subscription.status === 'cancel_requested')) {
                    
                    console.log('â° Subscription expired, downgrading to free tier');
                    
                    await updateDoc(userRef, {
                        'subscription.tier': 'free',
                        'subscription.status': 'expired',
                        'subscription.updatedAt': now,
                        'limits.maxAiGenerations': 5,
                        'limits.maxCards': 100,
                        'limits.maxDecks': 5,
                        'limits.maxSmartReviewDecks': 2,
                        'limits.maxFolders': 10
                    });
                    
                    const updatedDoc = await getDoc(userRef);
                    profileData = updatedDoc.data();
                }

                // Initialize gamification fields if needed
                if (profileData.exp === null || profileData.exp === undefined) {
                    const newFields = {
                        level: 1,
                        exp: 0,
                        health: 100,
                        mana: 100,
                        currentPartyId: null,
                        autoAssignedAt: null,
                        hasChosenAvatar: false,
                        avatar: "warrior_01",
                        prefersSolo: false,
                    };

                    await updateDoc(userRef, newFields);
                    const updatedDoc = await getDoc(userRef);
                    profileData = updatedDoc.data();
                }

                setUserProfile(profileData);
                setUser(prev => ({ ...prev, profile: profileData }));
            } else {
                // Create new user profile
                await createDefaultProfile(userId);
            }
        } catch (error) {
            console.error('âŒ Error fetching user profile:', error);
        }
    };

    const createDefaultProfile = async (userId) => {
        const now = new Date();
        const nextMonthStart = new Date(now.getFullYear(), now.getMonth() + 1, 1);
        const autoGeneratedDisplayName = generateRandomUsername();
        
        const defaultProfile = {
            email: auth.currentUser?.email,
            displayName: autoGeneratedDisplayName || "New User",
            createdAt: auth.currentUser?.metadata?.creationTime ? new Date(auth.currentUser.metadata.creationTime) : now,
            lastActiveAt: now,
            lastStudyDate: null,
            lastNameChangeAt: null,
            
            level: 1,
            exp: 0,
            health: 100,
            mana: 100,
            currentPartyId: null,
            autoAssignedAt: null,
            hasChosenAvatar: false,
            avatar: "warrior_01",
            prefersSolo: false,
            lastBossAttackAt: null,
            
            stats: {
                totalReviews: 0,
                weeklyReviews: 0,
                currentStreak: 0,
                longestStreak: 0
            },
            
            subscription: {
                tier: "free",
                expiresAt: null
            },
            
            limits: {
                aiGenerationsUsed: 0,
                currentCards: 0,
                currentDecks: 0,
                smartReviewDecks: 0,
                currentFolders: 0,
                aiGenerationsResetAt: nextMonthStart,
                maxAiGenerations: 5,
                maxCards: 100,
                maxDecks: 5,
                maxSmartReviewDecks: 2,
                maxFolders: 10
            },
            
            tutorials: {
                "create-deck": { completed: false, step: 1 },
                "global-review": { completed: false, step: 1 },
                "deck-sharing": { completed: false, step: 1 }
            }
        };

        const userRef = doc(db, 'users', userId);
        await setDoc(userRef, defaultProfile);
        
        const updatedDoc = await getDoc(userRef);
        const profileData = updatedDoc.data();
        setUserProfile(profileData);
        setUser(prev => ({ ...prev, profile: profileData }));
    };

    const generateRandomUsername = () => {
        const adjectives = ['Swift', 'Brave', 'Clever', 'Bright', 'Bold'];
        const nouns = ['Scholar', 'Learner', 'Student', 'Warrior', 'Master'];
        const num = Math.floor(Math.random() * 999) + 1;
        return `${adjectives[Math.floor(Math.random() * adjectives.length)]}${nouns[Math.floor(Math.random() * nouns.length)]}${num}`;
    };

    const signUp = async (email, password, displayName = null) => {
        setAuthLoading(true);
        try {
            const { user: newUser } = await createUserWithEmailAndPassword(auth, email, password);
            
            if (displayName) {
                await updateProfile(newUser, { displayName });
            }
            
            return { success: true, user: newUser };
        } catch (error) {
            console.error('Error signing up:', error);
            return { success: false, error: error.message };
        } finally {
            setAuthLoading(false);
        }
    };

    const signIn = async (email, password) => {
        setAuthLoading(true);
        try {
            const { user } = await signInWithEmailAndPassword(auth, email, password);
            return { success: true, user };
        } catch (error) {
            console.error('Error signing in:', error);
            return { success: false, error: error.message };
        } finally {
            setAuthLoading(false);
        }
    };

    const logOut = async () => {
        setAuthLoading(true);
        try {
            await signOut(auth);
            setUser(null);
            setUserProfile(null);
            return { success: true };
        } catch (error) {
            console.error('Error signing out:', error);
            return { success: false, error: error.message };
        } finally {
            setAuthLoading(false);
        }
    };

    const resetPassword = async (email) => {
        setAuthLoading(true);
        try {
            await sendPasswordResetEmail(auth, email);
            return { success: true };
        } catch (error) {
            console.error('Error resetting password:', error);
            return { success: false, error: error.message };
        } finally {
            setAuthLoading(false);
        }
    };

    const refreshUserProfile = useCallback(async () => {
        if (user?.uid) {
            await fetchUserProfile(user.uid);
        }
    }, []);

    const isPremium = () => {
        return userProfile?.subscription?.tier === 'premium' || 
               userProfile?.subscription?.tier === 'pro';
    };

    const getAILimits = () => {
        const limits = userProfile?.limits || {};
        const maxGenerations = limits.maxAiGenerations || 5;
        const currentUsage = limits.aiGenerationsUsed || 0;
        const resetDate = limits.aiGenerationsResetAt;
        
        return {
            maxGenerations,
            currentUsage,
            remaining: maxGenerations === -1 ? 'unlimited' : Math.max(0, maxGenerations - currentUsage),
            resetDate: resetDate?.toDate ? resetDate.toDate() : resetDate,
            canGenerate: maxGenerations === -1 || currentUsage < maxGenerations
        };
    };

    const getFolderLimits = () => {
        const limits = userProfile?.limits || {};
        const maxFolders = limits.maxFolders || 10;
        const currentUsage = limits.currentFolders || 0;

        return {
            maxFolders,
            canGenerate: maxFolders === -1 || currentUsage < maxFolders
        };
    };

    const getDeckLimits = () => {
        const limits = userProfile?.limits || {};
        const maxDecks = limits.maxDecks || 5;
        const currentUsage = limits.currentDecks || 0;

        return {
            maxDecks,
            canGenerate: maxDecks === -1 || currentUsage < maxDecks
        };
    };

    const getCardLimits = () => {
        const limits = userProfile?.limits || {};
        const maxCards = limits.maxCards || 100;
        const currentUsage = limits.currentCards || 0;

        return {
            maxCards,
            canGenerate: maxCards === -1 || currentUsage < maxCards,
            currentUsage
        };
    };

    const updateUserProfile = useCallback((updates) => {
        setUserProfile(prev => {
            if (!prev) return prev;
            return {
                ...prev,
                ...updates
            };
        });
    }, []);

     const value = useMemo(() => ({
        // Auth state
        user,
        userProfile,
        loading,
        authLoading,
        
        // Auth functions
        signIn,
        signUp,
        logOut,
        resetPassword,
        refreshUserProfile,
        
        // Limit functions
        isPremium,
        getAILimits,
        getFolderLimits,
        getDeckLimits,
        getCardLimits,

        // Setters
        updateUserProfile
    }), [
        user,
        userProfile,
        loading,
        authLoading,
        signIn,
        signUp,
        logOut,
        resetPassword,
        refreshUserProfile,
        isPremium,
        getAILimits,
        getFolderLimits,
        getDeckLimits,
        getCardLimits,
        updateUserProfile
    ]);

    return (
        <AuthContext.Provider value={value}>
            {!loading && children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const { user, loading, authLoading } = useAuthContext();
    return { user, loading: loading || authLoading };
};

export default AuthContext;